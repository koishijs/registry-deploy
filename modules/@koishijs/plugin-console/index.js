import{Buffer as h}from"https://registry.koishi.chat/modules/buffer/index.js";import u from"https://registry.koishi.chat/modules/process/index.js";import{Schema as N}from"https://registry.koishi.chat/modules/koishi/index.js";import{makeArray as _,Random as S,Service as O}from"https://registry.koishi.chat/modules/koishi/index.js";import{Service as P}from"https://registry.koishi.chat/modules/koishi/index.js";import{coerce as j,Logger as E,Random as C}from"https://registry.koishi.chat/modules/koishi/index.js";var f=Object.defineProperty,w=(e,t,r)=>t in e?f(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,o=(e,t)=>f(e,"name",{value:t,configurable:!0}),m=(e,t,r)=>(w(e,typeof t!="symbol"?t+"":t,r),r),y=class extends P{constructor(e,t,r={}){super(e,`console.${t}`,r.immediate),this.ctx=e,this.key=t,this.options=r,y.define(t)}static define(e){if(this.keys.add(e),Object.prototype.hasOwnProperty.call(p.prototype,e))return;let t=`console.${e}`;Object.defineProperty(p.prototype,e,{get(){return this.caller[t]},set(r){this.caller[t]=r}})}get(e){return null}start(){this.refresh()}async refresh(){this.ctx.console?.broadcast("data",{key:this.key,value:await this.get(!0)},this.options)}patch(e){this.ctx.console?.broadcast("patch",{key:this.key,value:e},this.options)}},a=y;o(a,"DataService");m(a,"keys",new Set);var v=class extends a{constructor(e){super(e,"schema",{immediate:!0}),e.on("internal/schema",()=>this.refresh())}async get(){return this.ctx.schema._data}};o(v,"SchemaProvider");var d=new E("console"),b=class{constructor(e,t){this.ctx=e,this.socket=t,t.addEventListener("message",this.receive),e.on("dispose",()=>{t.removeEventListener("message",this.receive)}),this.refresh()}id=C.id();send(e){this.socket.send(JSON.stringify(e))}receive=async e=>{let{type:t,args:r,id:i}=JSON.parse(e.data.toString()),n=this.ctx.console.listeners[t];if(!n)return d.info("unknown message:",t,...r),this.send({type:"response",body:{id:i,error:"not implemented"}});if(await this.ctx.serial("console/intercept",this,n))return this.send({type:"response",body:{id:i,error:"unauthorized"}});try{let s=await n.callback.call(this,...r);return this.send({type:"response",body:{id:i,value:s}})}catch(s){d.debug(s);let x=j(s);return this.send({type:"response",body:{id:i,error:x}})}};refresh(){a.keys.forEach(async e=>{let t=this.ctx[`console.${e}`];if(t){if(await this.ctx.serial("console/intercept",this,t.options))return this.send({type:"data",body:{key:e,value:null}});try{let r=await t.get();if(!r)return;this.send({type:"data",body:{key:e,value:r}})}catch(r){d.warn(r)}}})}};o(b,"Client");var g=class extends a{constructor(e){super(e,"entry",{immediate:!0})}async get(){return this.ctx.console.get()}};o(g,"EntryProvider");var c=class extends O{constructor(e){super(e,"console",!0),this.ctx=e,e.plugin(g),e.plugin(v)}entries=Object.create(null);listeners=Object.create(null);clients=Object.create(null);accept(e){let t=new b(this.ctx,e);e.addEventListener("close",()=>{delete this.clients[t.id],this.ctx.emit("console/connection",t)}),this.clients[t.id]=t,this.ctx.emit("console/connection",t)}async get(){return Object.values(this.entries).flat()}addEntry(e){let t=this.caller,r="extension-"+S.id();this.entries[r]=_(this.resolveEntry(e)),this.entry.refresh(),t?.on("dispose",()=>{delete this.entries[r],this.entry?.refresh()})}addListener(e,t,r){this.listeners[e]={callback:t,...r}}broadcast(e,t,r={}){if(!Object.values(this.clients).length)return;let n=JSON.stringify({type:e,body:t});Promise.all(Object.values(this.clients).map(async s=>{await this.ctx.serial("console/intercept",s,r)||s.socket.send(n)}))}};o(c,"Console");m(c,"filter",!1);var p=c;var k=Object.defineProperty,L=(e,t)=>k(e,"name",{value:t,configurable:!0}),l=class extends c{start(){this.accept(this.ctx.loader[Symbol.for("koishi.socket")])}resolveEntry(e){return typeof e=="string"||Array.isArray(e)?e:e.prod}};L(l,"BrowserConsole");(e=>{e.Config=N.object({})})(l||(l={}));var T=l;export{b as Client,c as Console,a as DataService,g as EntryProvider,T as default};
